/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, visit the plugin's github repository
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ScripterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var SCRIPT_MARKERS = {
  CHARACTER: "@",
  PARENTHETICAL: "("
};
var SCENE_REGEX = /^(\d+[.\s]\s*)?((?:INT|EXT|INT\/EXT|I\/E)[.\s]|\.[^.])/i;
var TRANSITION_REGEX = /^((?:FADE (?:IN|OUT)|[A-Z\s]+ TO)(?:[:.]?))$/;
var PARENTHETICAL_REGEX = /^(\(|（).+(\)|）)\s*$/i;
var OS_DIALOGUE_REGEX = /^(OS|VO|ＯＳ|ＶＯ)[:：]\s*/i;
var CHARACTER_COLON_REGEX = /^([\u4e00-\u9fa5A-Z0-9\s-]{1,30})[:：]\s*(.*)$/;
var CSS_CLASSES = {
  SCENE: "script-scene",
  CHARACTER: "script-character",
  DIALOGUE: "script-dialogue",
  PARENTHETICAL: "script-parenthetical",
  TRANSITION: "script-transition",
  ACTION: "script-action"
};
var LP_CLASSES = {
  SCENE: "lp-scene",
  CHARACTER: "lp-character",
  DIALOGUE: "lp-dialogue",
  PARENTHETICAL: "lp-parenthetical",
  TRANSITION: "lp-transition",
  SYMBOL: "lp-marker-symbol"
};
var ScripterPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.addSettingTab(new ScripterSettingTab(this.app, this));
    this.addCommand({
      id: "renumber-scenes",
      name: "Renumber scenes",
      editorCallback: (editor) => this.renumberScenes(editor)
    });
    this.addRibbonIcon("scroll-text", "New script", () => {
      this.createNewScript();
    });
    this.addCommand({
      id: "create-new-script",
      name: "Create new script",
      callback: () => this.createNewScript()
    });
    this.registerMarkdownPostProcessor((element, context) => {
      const frontmatter = context.frontmatter;
      const cssClasses = frontmatter == null ? void 0 : frontmatter.cssclasses;
      const classesArray = Array.isArray(cssClasses) ? cssClasses : typeof cssClasses === "string" ? [cssClasses] : [];
      if (!classesArray.includes("fountain") && !classesArray.includes("script")) {
        return;
      }
      const paragraphs = element.querySelectorAll("p");
      let globalPreviousType = "ACTION";
      paragraphs.forEach((p) => {
        const sectionInfo = context.getSectionInfo(p);
        let sourceLines = [];
        if (sectionInfo) {
          const { text: fullSource, lineStart, lineEnd } = sectionInfo;
          sourceLines = fullSource.split("\n").slice(lineStart, lineEnd + 1);
        } else {
          const text = p.textContent || "";
          sourceLines = text.split("\n");
        }
        p.empty();
        sourceLines.forEach((lineText) => {
          const trimmedLine = lineText.trim();
          if (!trimmedLine) {
            globalPreviousType = "ACTION";
            return;
          }
          const format = this.detectExplicitFormat(trimmedLine);
          const container = p.createDiv();
          if (format) {
            container.addClass(format.cssClass);
            let displayText = trimmedLine;
            if (format.removePrefix) {
              displayText = trimmedLine.substring(format.markerLength).trim();
            }
            const colonMatch = displayText.match(CHARACTER_COLON_REGEX);
            if (format.typeKey === "CHARACTER" && colonMatch) {
              const [_, charName, dialogueText] = colonMatch;
              container.setText(charName);
              if (dialogueText.trim()) {
                const diagDiv = p.createDiv(CSS_CLASSES.DIALOGUE);
                diagDiv.setText(dialogueText.trim());
                globalPreviousType = "DIALOGUE";
              } else {
                globalPreviousType = "CHARACTER";
              }
            } else {
              container.setText(displayText);
              globalPreviousType = format.typeKey;
            }
          } else if (globalPreviousType === "CHARACTER" || globalPreviousType === "PARENTHETICAL" || globalPreviousType === "DIALOGUE") {
            container.addClass(CSS_CLASSES.DIALOGUE);
            container.setText(trimmedLine);
            globalPreviousType = "DIALOGUE";
          } else {
            container.addClass(CSS_CLASSES.ACTION);
            container.setText(trimmedLine);
            globalPreviousType = "ACTION";
          }
        });
      });
    });
    this.registerEditorExtension(this.livePreviewExtension());
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        var _a;
        const fileCache = view.file ? this.app.metadataCache.getFileCache(view.file) : null;
        const cssClasses = (_a = fileCache == null ? void 0 : fileCache.frontmatter) == null ? void 0 : _a.cssclasses;
        const classesArray = Array.isArray(cssClasses) ? cssClasses : typeof cssClasses === "string" ? [cssClasses] : [];
        if (!classesArray.includes("fountain") && !classesArray.includes("script")) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Scripter").setIcon("film");
          const subMenu = item.setSubmenu();
          subMenu.addItem((startItem) => {
            startItem.setTitle("Scene heading").setIcon("clapperboard");
            const sceneMenu = startItem.setSubmenu();
            sceneMenu.addItem((i) => i.setTitle("EXT.").onClick(() => this.insertText(editor, "EXT. ", false)));
            sceneMenu.addItem((i) => i.setTitle("INT.").onClick(() => this.insertText(editor, "INT. ", false)));
            sceneMenu.addItem((i) => i.setTitle("I/E.").onClick(() => this.insertText(editor, "INT./EXT. ", false)));
          });
          this.addMenuItem(subMenu, "Character (@)", "user", editor, SCRIPT_MARKERS.CHARACTER);
          this.addMenuItem(subMenu, "Parenthetical ( ( )", "italic", editor, SCRIPT_MARKERS.PARENTHETICAL);
          subMenu.addItem((item2) => {
            item2.setTitle("Transition").setIcon("arrow-right");
            const m = item2.setSubmenu();
            m.addItem((i) => i.setTitle("CUT TO:").onClick(() => this.insertText(editor, "CUT TO:", true)));
            m.addItem((i) => i.setTitle("FADE OUT.").onClick(() => this.insertText(editor, "FADE OUT.", true)));
            m.addItem((i) => i.setTitle("FADE IN:").onClick(() => this.insertText(editor, "FADE IN:", true)));
            m.addItem((i) => i.setTitle("DISSOLVE TO:").onClick(() => this.insertText(editor, "DISSOLVE TO:", true)));
          });
          subMenu.addSeparator();
          subMenu.addItem((subItem) => {
            subItem.setTitle("Renumber scenes").setIcon("list-ordered").onClick(() => this.renumberScenes(editor));
          });
          subMenu.addItem((subItem) => {
            subItem.setTitle("Clear format").setIcon("eraser").onClick(() => this.clearLinePrefix(editor));
          });
        });
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        menu.addItem((item) => {
          item.setTitle("New script").setIcon("scroll-text").onClick(async () => {
            var _a;
            let folderPath = "/";
            if (file instanceof import_obsidian.TFolder) {
              folderPath = file.path;
            } else if (file instanceof import_obsidian.TFile) {
              folderPath = ((_a = file.parent) == null ? void 0 : _a.path) || "/";
            }
            await this.createNewScript(folderPath);
          });
        });
      })
    );
  }
  onunload() {
  }
  // ------------------------------------------------------------------
  // Live Preview Extension (CodeMirror 6)
  // ------------------------------------------------------------------
  livePreviewExtension() {
    return import_view.ViewPlugin.fromClass(class {
      constructor(view) {
        this.decorations = this.buildDecorations(view);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged || update.selectionSet) {
          this.decorations = this.buildDecorations(update.view);
        }
      }
      buildDecorations(view) {
        const builder = new import_state.RangeSetBuilder();
        const isScript = view.dom.closest(".fountain") || view.dom.closest(".script");
        if (!isScript)
          return builder.finish();
        const selection = view.state.selection;
        let previousType = null;
        const hiddenDeco = import_view.Decoration.mark({ class: LP_CLASSES.SYMBOL });
        for (const { from, to } of view.visibleRanges) {
          for (let pos = from; pos <= to; ) {
            const line = view.state.doc.lineAt(pos);
            const text = line.text;
            const trimmed = text.trim();
            let lpClass = null;
            let currentType = "ACTION";
            let shouldHideMarker = false;
            let isCursorOnLine = false;
            for (const range of selection.ranges) {
              if (range.head >= line.from && range.head <= line.to) {
                isCursorOnLine = true;
                break;
              }
            }
            if (!trimmed) {
              currentType = "EMPTY";
            } else if (SCENE_REGEX.test(text)) {
              lpClass = LP_CLASSES.SCENE;
              currentType = "SCENE";
              if (!isCursorOnLine && text.startsWith(".")) {
                shouldHideMarker = true;
              }
            } else if (TRANSITION_REGEX.test(text)) {
              lpClass = LP_CLASSES.TRANSITION;
              currentType = "TRANSITION";
            } else if (PARENTHETICAL_REGEX.test(text)) {
              lpClass = LP_CLASSES.PARENTHETICAL;
              currentType = "PARENTHETICAL";
            } else if (text.startsWith(SCRIPT_MARKERS.CHARACTER) || /^[A-Z0-9\s-]{1,30}(\s+\([^)]+\))?$/.test(text) && text.length > 0 || /^[\u4e00-\u9fa5A-Z0-9\s-]{1,30}$/.test(text) || CHARACTER_COLON_REGEX.test(text)) {
              lpClass = LP_CLASSES.CHARACTER;
              currentType = "CHARACTER";
              if (!isCursorOnLine && text.startsWith(SCRIPT_MARKERS.CHARACTER)) {
                shouldHideMarker = true;
              }
            } else if (OS_DIALOGUE_REGEX.test(text)) {
              lpClass = LP_CLASSES.PARENTHETICAL;
              currentType = "PARENTHETICAL";
            } else {
              if (previousType === "CHARACTER" || previousType === "PARENTHETICAL" || previousType === "DIALOGUE") {
                lpClass = LP_CLASSES.DIALOGUE;
                currentType = "DIALOGUE";
              } else {
                currentType = "ACTION";
              }
            }
            if (lpClass) {
              builder.add(line.from, line.from, import_view.Decoration.line({
                attributes: { class: lpClass }
              }));
            }
            if (shouldHideMarker) {
              builder.add(line.from, line.from + 1, hiddenDeco);
            }
            previousType = currentType;
            pos = line.to + 1;
          }
        }
        return builder.finish();
      }
    }, {
      decorations: (v) => v.decorations
    });
  }
  // ------------------------------------------------------------------
  // Core Logic
  // ------------------------------------------------------------------
  addMenuItem(menu, title, icon, editor, marker) {
    if (menu instanceof import_obsidian.Menu) {
      menu.addItem((item) => {
        item.setTitle(title).setIcon(icon).onClick(() => this.toggleLinePrefix(editor, marker));
      });
    }
  }
  detectExplicitFormat(text) {
    if (SCENE_REGEX.test(text)) {
      const isForcedScene = text.startsWith(".");
      return {
        cssClass: CSS_CLASSES.SCENE,
        removePrefix: isForcedScene,
        markerLength: isForcedScene ? 1 : 0,
        typeKey: "SCENE"
      };
    }
    if (TRANSITION_REGEX.test(text)) {
      return { cssClass: CSS_CLASSES.TRANSITION, removePrefix: false, markerLength: 0, typeKey: "TRANSITION" };
    }
    if (PARENTHETICAL_REGEX.test(text)) {
      return { cssClass: CSS_CLASSES.PARENTHETICAL, removePrefix: false, markerLength: 0, typeKey: "PARENTHETICAL" };
    }
    if (OS_DIALOGUE_REGEX.test(text)) {
      return { cssClass: CSS_CLASSES.PARENTHETICAL, removePrefix: false, markerLength: 0, typeKey: "PARENTHETICAL" };
    }
    if (text.startsWith(SCRIPT_MARKERS.CHARACTER))
      return { cssClass: CSS_CLASSES.CHARACTER, removePrefix: true, markerLength: 1, typeKey: "CHARACTER" };
    const isEnglishName = /^[A-Z0-9\s-]{1,30}(\s+\([^)]+\))?$/.test(text) && text.length > 0;
    const isChineseName = /^[\u4e00-\u9fa5A-Z0-9\s-]{1,30}$/.test(text) || CHARACTER_COLON_REGEX.test(text);
    if (isEnglishName || isChineseName) {
      return { cssClass: CSS_CLASSES.CHARACTER, removePrefix: false, markerLength: 0, typeKey: "CHARACTER" };
    }
    return null;
  }
  renumberScenes(editor) {
    const lineCount = editor.lineCount();
    let sceneCounter = 0;
    for (let i = 0; i < lineCount; i++) {
      const line = editor.getLine(i);
      const trimmed = line.trim();
      const match = trimmed.match(SCENE_REGEX);
      if (match) {
        sceneCounter++;
        const sceneNumStr = sceneCounter.toString().padStart(2, "0") + ". ";
        let contentWithoutNumber = trimmed;
        if (match[1]) {
          contentWithoutNumber = trimmed.replace(/^\d+[.\s]\s*/, "");
        }
        contentWithoutNumber = contentWithoutNumber.trim();
        const newLine = sceneNumStr + contentWithoutNumber;
        if (newLine !== line) {
          editor.setLine(i, newLine);
        }
      }
    }
  }
  toggleLinePrefix(editor, prefix) {
    const cursor = editor.getCursor();
    const lineContent = editor.getLine(cursor.line);
    let newLineContent = lineContent;
    let hasMarker = false;
    for (const marker of Object.values(SCRIPT_MARKERS)) {
      if (lineContent.trim().startsWith(marker)) {
        const matchIndex = lineContent.indexOf(marker);
        const before = lineContent.substring(0, matchIndex);
        const after = lineContent.substring(matchIndex + marker.length);
        if (marker === prefix) {
          newLineContent = before + after;
          hasMarker = true;
        } else {
          newLineContent = before + prefix + after;
          hasMarker = true;
        }
        break;
      }
    }
    if (!hasMarker)
      newLineContent = prefix + lineContent;
    editor.setLine(cursor.line, newLineContent);
  }
  insertText(editor, text, replaceLine = false) {
    const cursor = editor.getCursor();
    const lineContent = editor.getLine(cursor.line);
    if (replaceLine) {
      editor.setLine(cursor.line, text);
    } else {
      editor.setLine(cursor.line, text + lineContent);
    }
  }
  clearLinePrefix(editor) {
    const cursor = editor.getCursor();
    const lineContent = editor.getLine(cursor.line);
    let newLineContent = lineContent;
    for (const marker of Object.values(SCRIPT_MARKERS)) {
      if (lineContent.trim().startsWith(marker)) {
        const matchIndex = lineContent.indexOf(marker);
        const before = lineContent.substring(0, matchIndex);
        const after = lineContent.substring(matchIndex + marker.length);
        newLineContent = before + after;
        editor.setLine(cursor.line, newLineContent);
        return;
      }
    }
  }
  async createNewScript(folderPath) {
    var _a;
    let targetFolder = folderPath;
    if (!targetFolder) {
      const activeFile = this.app.workspace.getActiveFile();
      targetFolder = activeFile ? ((_a = activeFile.parent) == null ? void 0 : _a.path) || "/" : "/";
    }
    const baseName = "Untitled Script";
    let fileName = `${baseName}.md`;
    let filePath = targetFolder === "/" ? fileName : `${targetFolder}/${fileName}`;
    let counter = 1;
    while (await this.app.vault.adapter.exists(filePath)) {
      fileName = `${baseName} ${counter}.md`;
      filePath = targetFolder === "/" ? fileName : `${targetFolder}/${fileName}`;
      counter++;
    }
    const frontmatterContent = "---\ncssclasses: fountain\n---\n\n";
    const newFile = await this.app.vault.create(filePath, frontmatterContent);
    const leaf = this.app.workspace.getLeaf(false);
    await leaf.openFile(newFile);
    this.app.workspace.trigger("rename", newFile, newFile.path);
  }
};
var ScripterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Usage guide").setHeading();
    new import_obsidian.Setting(containerEl).setName("Getting started").setDesc("How to activate screenplay formatting for a specific note.").setHeading();
    const setupInfo = containerEl.createEl("div", { cls: "setting-item-description" });
    setupInfo.createEl("p", { text: "To enable Scripter features (Live Preview & Print Formatting), adds the following to your note's frontmatter (Properties):" });
    setupInfo.createEl("pre", { text: "---\ncssclasses: fountain\n---" });
    setupInfo.createEl("p", { text: 'Or use "script" instead of "fountain".' });
    containerEl.createEl("br");
    new import_obsidian.Setting(containerEl).setName("Syntax reference").setDesc("Basic rules for formatting your screenplay.").setHeading();
    const syntaxDiv = containerEl.createEl("div");
    const createRow = (title, syntax, desc) => {
      const p = syntaxDiv.createEl("p");
      p.createEl("strong", { text: title + ": " });
      p.createEl("code", { text: syntax });
      p.createSpan({ text: " \u2014 " + desc });
    };
    createRow("Scene Heading", "INT. / EXT.", "Automatic bold & uppercase.");
    createRow("Character", "@NAME", 'Centered. "@" is hidden when not editing.');
    createRow("Dialogue", "Text below Character", "Automatically indented.");
    createRow("Parenthetical", "(emotion) / OS: / VO:", "Centered & Italic.");
    createRow("Transition", "CUT TO: / FADE IN", "Right aligned.");
    containerEl.createEl("br");
    const supportDiv = containerEl.createEl("div", { attr: { style: "margin-top: 20px; border-top: 1px solid var(--background-modifier-border); padding-top: 20px;" } });
    supportDiv.createEl("p", { text: "If you enjoy using Scripter, consider support its development!" });
    const link = supportDiv.createEl("a", { href: "https://buymeacoffee.com/ideo2004c" });
    link.createEl("img", {
      attr: {
        src: "https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png",
        style: "height: 40px;"
      }
    });
  }
};
